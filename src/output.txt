stabilizer_circuit.h:
#pragma once

#include "stabilizer_tableau.h"

#include <iostream>
#include <cstdint>
#include <stdexcept>
#include <cstdint>
#include <vector>
#include <array>
#include <fstream>
#include <sstream>
#include <regex>
#include <utility>
#include <random>
#include <complex>
#include <filesystem>

namespace CliffordTableaus {
    using uint = std::size_t;
    static const std::regex qreg_regex = std::regex(R"(^qreg q\[(\d+)\];$)");
    static const std::regex id_regex = std::regex(R"(^id q\[(\d+)\];$)");
    static const std::regex cnot_regex = std::regex(R"(^cx q\[(\d+)\],q\[(\d+)\];$)");
    static const std::regex h_regex = std::regex(R"(^h q\[(\d+)\];$)");
    static const std::regex s_regex = std::regex(R"(^s q\[(\d+)\];$)");
    static const std::regex x_regex = std::regex(R"(^x q\[(\d+)\];$)");
    static const std::regex y_regex = std::regex(R"(^y q\[(\d+)\];$)");
    static const std::regex z_regex = std::regex(R"(^z q\[(\d+)\];$)");
    static const std::regex measure_regex = std::regex(R"(^measure q\[(\d+)\];$)");

    class StabilizerCircuit {
    private:
        /**
         * Create the file containing the circuit.
         * @param circuit_filename File containing the circuit in QASM3 format.
         * @param overwrite_file Whether the file should be overwritten if it already exists.
         * @return An output file stream to the circuit file.
         */
        static std::ofstream createCircuitFile(const std::string &circuit_filename, bool overwrite_file);

        /**
         * Retrieve the file containing the circuit.
         * @param circuit_filename File containing the circuit in QASM3 format.
         * @return A file stream to the circuit file.
         */
        static std::ifstream retrieveCircuitFile(const std::string &circuit_filename);

        /**
         * Apply the operation given by the line, which is expected to be in QASM3 syntax to the tableau.
         * In case the operation has an effect on the measurement results, update the measurement result string.
         * @param line Line in QASM3 syntax which describes the operation to perform.
         * @param tableau Utilized Tableau to apply the operation to.
         * @param measurement_result String with running measurement results.
         * @return Whether the operation was successfully applied.
         */
        static bool applyGateLine(const std::string &line, StabilizerTableau &tableau, std::string &measurement_result);

    public:

        /**
         * Execute a stabilizer circuit given by the QASM3 code in the file given by circuit_filename
         * using the provided stabilizer tableau.
         * If qubits are measured without further operations, the returned string will contain the measurement results.
         * In place of all unmeasured qubits, the return string will contain 'x'.
         * @param circuit_filename File containing the circuit in QASM3 format.
         * @param tableau Stabilizer tableau to use to execute the circuit.
         * @return The final measurement of the executed circuit
         * using '0' and '1' for measured qubits and 'x' for unmeasured qubits.
         */
        static std::string executeCircuit(const std::string &circuit_filename, StabilizerTableau &tableau);

        /**
         * Launch the interactive mode for executing stabilizer circuits.
         * The interactive mode allows the user to dynamically and consecutively apply gates to the stabilizer tableau.
         * Supported gates are Pauli-X, Pauli-Y, Pauli-Z, CNOT, Hadamard, Phase, and Measurement.
         * Commands must be provided in the QASM3 syntax.
         * All commands not in QASM3 syntax will default to NO-OP.
         * Use "exit" or "quit" to exit the interactive mode and output the measurement results.
         * Use "finish" or "measure all" to measure all remaining qubits and output the measurement results.
         * @param tableau Stabilizer tableau to use for the interactive mode.
         */
        static std::string interactiveMode(StabilizerTableau &tableau);

        /**
         * Create a random stabilizer circuit and write it to a file.
         * @param circuit_filename Name of the file to write the circuit to.
         * @param n_qubits Number of qubits in the system.
         * @param depth Number of gates in the circuit.
         * @param gate_seed Seed for the random number generator for selecting gates.
         * @param qubit_seed Seed for the random number generator for selecting qubits.
         * @param allow_intermediate_measurement Whether the circuit measures qubits intermediately during execution.
         * @param measure_all_at_the_end Whether the circuit should measure all qubits at the end.
         * @param overwrite_file Whether the file should be overwritten if it already exists.
         */
        static void createRandomStabilizerCircuit(
                const std::string &circuit_filename,
                uint n_qubits,
                uint depth,
                uint gate_seed = 0,
                uint qubit_seed = 0,
                bool allow_intermediate_measurement = false,
                bool measure_all_at_the_end = true,
                bool overwrite_file = false
        );

        /**
         * Write a stabilizer circuit to a file.
         * @param circuit_filename Name of the file to write the circuit to.
         * @param circuit Stabilizer circuit in QASM3 format.
         * @param overwrite_file Whether the file should be overwritten if it already exists.
         */
        static void writeStabilizerCircuitToFile(
                const std::string &circuit_filename,
                const std::string &circuit,
                bool overwrite_file
        );

        /**
         * Get the string of a line of QASM3 code which applies the CNOT gate
         * to target qubit depending on the control qubit.
         * @param control Control qubit.
         * @param target Target qubit to apply the X-gate to if the control qubit is |1〉.
         * @return Line of QASM3 code corresponding to the application of the CNOT gate
         * with the given control and target qubits.
         */
        static std::string getCNOT(uint control, uint target);

        /**
         * Get the string of a line of QASM3 code which applies the Hadamard gate to the qubit.
         * @param qubit Qubit to apply the Hadamard gate to.
         * @return Line of QASM3 code corresponding to the application of the Hadamard gate to the qubit.
         */
        static std::string getHadamard(uint qubit);

        /**
         * Get the string of a line of QASM3 code which applies the Phase gate to the qubit.
         * @param qubit Qubit to apply the Phase gate to.
         * @return Line of QASM3 code corresponding to the application of the Phase gate to the qubit.
         */
        static std::string getPhase(uint qubit);

        /**
         * Get the string of a line of QASM3 code which measures the qubit.
         * @param qubit Qubit to measure.
         * @return Line of QASM3 code corresponding to the measurement of the qubit.
         */
        static std::string getMeasurement(uint qubit);


        /**
         * Get the string of a line of QASM3 code which applies the identity gate to the qubit.
         * @param qubit Qubit to apply the identity gate to.
         * @return Line of QASM3 code corresponding to the application of the identity gate to the qubit.
         */
        static std::string getIdentity(uint qubit);

        /**
         * Get the string of a line of QASM3 code which applies the Pauli-X gate to the qubit.
         * @param qubit Qubit to apply the Pauli-X gate to.
         * @return Line of QASM3 code corresponding to the application of the Pauli-X gate to the qubit.
         */
        static std::string getPauliX(uint qubit);

        /**
         * Get the string of a line of QASM3 code which applies the Pauli-Y gate to the qubit.
         * @param qubit Qubit to apply the Pauli-Y gate to.
         * @return Line of QASM3 code corresponding to the application of the Pauli-Y gate to the qubit.
         */
        static std::string getPauliY(uint qubit);

        /**
         * Get the string of a line of QASM3 code which applies the Pauli-Z gate to the qubit.
         * @param qubit Qubit to apply the Pauli-Z gate to.
         * @return Line of QASM3 code corresponding to the application of the Pauli-Z gate to the qubit.
         */
        static std::string getPauliZ(uint qubit);
    };

    /**
     * Trim the line by removing leading and trailing whitespace.
     * @param line Line to trim the leading and trailing whitespace from.
     */
    static void trimLine(std::string &line) {
        line.erase(line.begin(), std::find_if(line.begin(), line.end(), [](unsigned char c) {
            return !std::isspace(c);
        }));
        line.erase(std::find_if(line.rbegin(), line.rend(), [](unsigned char c) {
            return !std::isspace(c);
        }).base(), line.end());
    }

    /**
     * Supported gates in the stabilizer circuit.
     */
    enum Gate {
        IDENTITY,
        PAULI_X,
        PAULI_Y,
        PAULI_Z,
        CNOT,
        HADAMARD,
        PHASE,
        MEASURE
    };
}

stabilizer_circuit.cpp:

#include "stabilizer_circuit.h"


namespace CliffordTableaus {
    std::string StabilizerCircuit::executeCircuit(const std::string &circuit_filename, StabilizerTableau &tableau) {
        auto file = retrieveCircuitFile(circuit_filename);

        std::string line;
        if (!std::getline(file, line) || line != "OPENQASM 3;") {
            throw std::runtime_error("Invalid QASM format: missing 'OPENQASM 3;' on the first line.");
        }

        // Read the second line (qreg q[n];) and parse the number of qubits
        if (!std::getline(file, line)) {
            throw std::runtime_error("Invalid QASM format: missing 'qreg q[n];' on the second line.");
        }

        std::smatch match;
        if (!std::regex_match(line, match, qreg_regex)) {
            throw std::runtime_error("Invalid QASM format: 'qreg q[n];' expected on the second line.");
        }

        auto n = std::stoul(match[1]);
        tableau.initializeTableau(n);
        std::string measurement_result(n, 'x');

        while (std::getline(file, line)) {
            if (line.empty()) {
                continue;
            }
            // std::cout << line << std::endl;
            if (!applyGateLine(line, tableau, measurement_result)) {
                throw std::invalid_argument("Error! Expected file in QASM3 format.");
            }
        }
        return measurement_result;
    }


    std::string StabilizerCircuit::interactiveMode(StabilizerTableau &tableau) {
        uint n = 0;
        std::smatch match;
        while (true) {
            std::cout << "Initialize the number of qubit register in QASM3 format: qreg q[n];\n> ";
            std::string line;
            if (!std::getline(std::cin, line)) {
                // End input, just return empty
                return "";
            }
            trimLine(line);

            if (std::regex_match(line, match, qreg_regex)) {
                n = std::stoul(match[1]);
                break;
            } else {
                std::cout << "Error: Incorrect format. Expected format: qreg q[n];" << std::endl;
            }
        }

        tableau.initializeTableau(n);
        std::string measurement_result(n, 'x');
        std::cout << "Initialized circuit with " << n << " qubits.\n"
                  << "Available commands:\n"
                  << "Gates CNOT, H, S, Measure, X, Y, Z applied to qubits in QASM3 format.\n"
                  << "exit|quit => Terminate interactive mode and print current measurement string.\n"
                  << "finish|measure all => Measure all remaining qubits and print the measurement string.\n";

        std::string line;
        while (true) {
            std::cout << "> ";
            if (!std::getline(std::cin, line)) {
                // End of input
                break;
            }
            trimLine(line);

            if (line.empty()) {
                continue;
            }
            if (line == "exit" || line == "quit") {
                break;
            }
            if (line == "finish" || line == "measure all") {
                for (uint q_index = 0; q_index < n; ++q_index) {
                    if (measurement_result.at(q_index) == 'x') {
                        uint8_t measurement = tableau.Measurement(q_index + 1);
                        measurement_result.at(q_index) = static_cast<char>('0' + measurement);
                    }
                }
                break;
            }

            if (!applyGateLine(line, tableau, measurement_result)) {
                std::cout << "Error: Invalid input." << std::endl;
            }
        }
        return measurement_result;
    }

    bool StabilizerCircuit::applyGateLine(
            const std::string &line, StabilizerTableau &tableau, std::string &measurement_result
    ) {
        std::smatch match;
        if (std::regex_match(line, match, id_regex)) {
            uint q_index = std::stoul(match[1]);

            // Measurement result is not affected by the identity gate
            tableau.Identity(q_index + 1);

            return true;
        } else if (std::regex_match(line, match, cnot_regex)) {
            uint control = std::stoul(match[1]);
            uint target = std::stoul(match[2]);

            tableau.CNOT(control + 1, target + 1);
            measurement_result.at(control) = 'x';
            measurement_result.at(target) = 'x';

            return true;
        } else if (std::regex_match(line, match, h_regex)) {
            uint q_index = std::stoul(match[1]);

            tableau.Hadamard(q_index + 1);
            measurement_result.at(q_index) = 'x';

            return true;
        } else if (std::regex_match(line, match, s_regex)) {
            uint q_index = std::stoul(match[1]);

            tableau.Phase(q_index + 1);
            measurement_result.at(q_index) = 'x';

            return true;
        } else if (std::regex_match(line, match, measure_regex)) {
            uint q_index = std::stoul(match[1]);

            uint8_t measurement = tableau.Measurement(q_index + 1);
            measurement_result.at(q_index) = static_cast<char>('0' + measurement);

            return true;
        } else if (std::regex_match(line, match, x_regex)) {
            uint q_index = std::stoul(match[1].str());

            tableau.PauliX(q_index + 1);
            measurement_result.at(q_index) = 'x';

            return true;
        } else if (std::regex_match(line, match, y_regex)) {
            uint q_index = std::stoul(match[1].str());

            tableau.PauliY(q_index + 1);
            measurement_result.at(q_index) = 'x';

            return true;
        } else if (std::regex_match(line, match, z_regex)) {
            uint q_index = std::stoul(match[1].str());

            tableau.PauliZ(q_index + 1);
            measurement_result.at(q_index) = 'x';

            return true;
        } else {
            return false;
        }
    }


    void StabilizerCircuit::createRandomStabilizerCircuit(
            const std::string &circuit_filename,
            uint n_qubits,
            uint depth,
            uint gate_seed,
            uint qubit_seed,
            bool allow_intermediate_measurement,
            bool measure_all_at_the_end,
            bool overwrite_file
    ) {
        auto file = createCircuitFile(circuit_filename, overwrite_file);

        std::vector<Gate> allowed_gates = {PAULI_X, PAULI_Y, PAULI_Z, HADAMARD, PHASE};
        if (n_qubits >= 2) {
            allowed_gates.push_back(CNOT);
        }
        if (allow_intermediate_measurement) {
            allowed_gates.push_back(MEASURE);
        }

        std::mt19937 gate_generator(gate_seed);
        std::mt19937 qubit_generator(qubit_seed);
        std::discrete_distribution<int> gate_distribution;

        if (n_qubits >= 2 && allow_intermediate_measurement) {
            // 7 gates: X=0.16, Y=0.16, Z=0.16, CNOT=0.16, HADAMARD=0.16, PHASE=0.16, MEASURE=0.04
            auto p1 = 0.16;
            auto p2 = 0.04;
            gate_distribution = std::discrete_distribution<int>({p1, p1, p1, p1, p1, p1, p2});
        } else if (n_qubits >= 2) {
            // 6 gates: X=1/6, Y=1/6, Z=1/6, CNOT=1/6, HADAMARD=1/6, PHASE=1/6
            auto p = 1.0 / 6.0;
            gate_distribution = std::discrete_distribution<int>({p, p, p, p, p, p});
        } else if (allow_intermediate_measurement) {
            // 6 gates: X=0.19, Y=0.19, Z=0.19, HADAMARD=0.19, PHASE=0.19, MEASURE=0.05
            auto p1 = 0.19;
            auto p2 = 0.05;
            gate_distribution = std::discrete_distribution<int>({p1, p1, p1, p1, p1, p1, p2});
        } else {
            // 5 gates: X=1/5, Y=1/5, Z=1/5, HADAMARD=1/5, PHASE=1/5
            auto p = 0.2;
            gate_distribution = std::discrete_distribution<int>({p, p, p});
        }
        std::uniform_int_distribution<uint> qubit_dist(0, n_qubits - 1);

        file << "OPENQASM 3;\n";
        file << "qreg q[" << n_qubits << "];\n";
        for (int i = 0; i < depth; ++i) {
            uint q1 = qubit_dist(qubit_generator);
            uint q2 = 0;

            switch (allowed_gates[gate_distribution(gate_generator)]) {
                case IDENTITY:
                    throw std::logic_error("Identity gate should not be selected.");
                case PAULI_X:
                    file << getPauliX(q1);
                    break;
                case PAULI_Y:
                    file << getPauliY(q1);
                    break;
                case PAULI_Z:
                    file << getPauliZ(q1);
                    break;
                case CNOT:
                    q2 = qubit_dist(qubit_generator);
                    while (q2 == q1) {
                        q2 = qubit_dist(qubit_generator);
                    }
                    file << getCNOT(q1, q2);
                    break;
                case HADAMARD:
                    file << getHadamard(q1);
                    break;
                case PHASE:
                    file << getPhase(q1);
                    break;
                case MEASURE:
                    file << getMeasurement(q1);
                    break;
            }
        }

        if (measure_all_at_the_end) {
            for (uint qubit = 0; qubit < n_qubits; ++qubit) {
                file << "measure q[" << qubit << "];\n";
            }
        }
    }


    void StabilizerCircuit::writeStabilizerCircuitToFile(
            const std::string &circuit_filename,
            const std::string &circuit,
            bool overwrite_file
    ) {
        auto file = createCircuitFile(circuit_filename, overwrite_file);

        std::istringstream iss(circuit);
        std::string line;
        int line_number = 0;
        while (std::getline(iss, line)) {
            line_number++;

            // These two lines only remove leading and trailing whitespace from the entire line,
            // not the whitespace between words or tokens.
            // They use std::find_if to find the first and last non-whitespace characters.
            // All internal spacing, such as the space between "h" and "q[0];", remains intact.
            line.erase(line.begin(), std::find_if(line.begin(), line.end(), [](unsigned char c) {
                return !std::isspace(c);
            }));
            line.erase(std::find_if(line.rbegin(), line.rend(), [](unsigned char c) {
                return !std::isspace(c);
            }).base(), line.end());

            if (line_number == 1) {
                if (line != "OPENQASM 3;") {
                    throw std::invalid_argument("The format is wrong");
                }
                file << line << "\n";
                continue;
            }

            if (line_number == 2) {
                if (!std::regex_match(line, qreg_regex)) {
                    throw std::invalid_argument("The format is wrong.");
                }
                file << line << "\n";
                continue;
            }

            std::smatch match;
            if (std::regex_match(line, id_regex) ||
                std::regex_match(line, cnot_regex) ||
                std::regex_match(line, h_regex) ||
                std::regex_match(line, s_regex) ||
                std::regex_match(line, x_regex) ||
                std::regex_match(line, y_regex) ||
                std::regex_match(line, z_regex) ||
                std::regex_match(line, measure_regex)
                    ) {
                file << line << "\n";
            } else {
                // Check if line starts with a known gate token,
                // if not, it's unsupported or format is wrong.
                if (line.rfind("id", 0) == 0 ||
                    line.rfind("cx", 0) == 0 ||
                    line.rfind('h', 0) == 0 ||
                    line.rfind('s', 0) == 0 ||
                    line.rfind("measure", 0) == 0 ||
                    line.rfind('x', 0) == 0 ||
                    line.rfind('y', 0) == 0 ||
                    line.rfind('z', 0) == 0) {
                    throw std::invalid_argument("Gate not supported.");
                } else {
                    throw std::invalid_argument("Format wrong");
                }
            }
        }
    }

    std::ofstream StabilizerCircuit::createCircuitFile(const std::string &circuit_filename, bool overwrite_file) {
        // Get the directory of the current source file otherwise execution from different location will throw errors.
        // Ensure the directory exists by creating it if it doesn't.
        // Finally construct the full path to the file.
        namespace fs = std::filesystem;
        fs::path base_directory = fs::path(__FILE__).parent_path() / "stabilizer_circuits";
        fs::create_directories(base_directory);
        fs::path file_path = base_directory / circuit_filename;

        // If overwrite_file is true empty it and start writing it anew.
        // If overwrite_file is false, check if the file exists and throw an error if it does.
        if (!overwrite_file && fs::exists(file_path)) {
            throw std::invalid_argument("File already exists.");
        }
        std::ofstream file(file_path);
        if (!file.is_open()) {
            throw std::runtime_error("Unable to open file for writing.");
        }
        return file;
    }

    std::ifstream StabilizerCircuit::retrieveCircuitFile(const std::string &circuit_filename) {
        // Get the directory of the current source file otherwise execution from different location will throw errors.
        // Ensure the directory exists by creating it if it doesn't.
        namespace fs = std::filesystem;
        fs::path base_directory = fs::path(__FILE__).parent_path() / "stabilizer_circuits";
        fs::create_directories(base_directory);
        fs::path file_path = base_directory / circuit_filename;

        // Check if the file exists. If it doesn't, throw an error.
        if (!fs::exists(file_path)) {
            throw std::runtime_error("File does not exist: " + file_path.string());
        }

        // Open the file for reading.
        std::ifstream file(file_path);
        if (!file.is_open()) {
            throw std::runtime_error("Unable to open file for reading: " + file_path.string());
        }
        return file;
    }


    std::string StabilizerCircuit::getCNOT(uint control, uint target) {
        std::ostringstream builder;
        builder << "cx q[" << control << "],q[" << target << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getHadamard(uint qubit) {
        std::ostringstream builder;
        builder << "h q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getPhase(uint qubit) {
        std::ostringstream builder;
        builder << "s q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getMeasurement(uint qubit) {
        std::ostringstream builder;
        builder << "measure q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getIdentity(uint qubit) {
        std::ostringstream builder;
        builder << "id q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getPauliX(uint qubit) {
        std::ostringstream builder;
        builder << "x q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getPauliY(uint qubit) {
        std::ostringstream builder;
        builder << "y q[" << qubit << "];\n";
        return builder.str();
    }

    std::string StabilizerCircuit::getPauliZ(uint qubit) {
        std::ostringstream builder;
        builder << "z q[" << qubit << "];\n";
        return builder.str();
    }
}


stabilizer_tableau.h:
#pragma once

#include <cstdint>
#include <stdexcept>
#include <cstdint>
#include <vector>


namespace CliffordTableaus {
    using uint = std::size_t;

    class StabilizerTableau {
    protected:
        /**
         * The number of qubits in the system.
         */
        uint n{};

        /**
         * The total number of bits needed to specify the state.
         * Also total number of bits in the tableau.
         */
        uint total_bits{};

        /**
         * The tableau of stabilizer and destabilizer generators.
         * The destabilizer generators occupy the first n rows of the tableau.
         * The stabilizer generators occupy the next n rows.
         * It is convenient to add an additional (2n+1)-st row for scratch space.
         * Therefore the tableau is (2n+1)x(2n+1) big.
         */
        std::vector<uint8_t> tableau;

        /**
         * Default Constructor exclusively for the subclasses.
         */
        explicit StabilizerTableau() = default;

        /**
        * Initialize the tableau with the given number of qubits and total bits.
        * @param p_n Number of qubits in the system.
        * @param p_total_bits Number of bits necessary to specify the state using the tableau.
        */
        void initializeTableau(uint p_n, uint p_total_bits);

    public:
        /**
         * Initialize the tableau with the given number of qubits.
         * The overriding subclass must determine the amount of necessary total_bits from the amount of qubits
         * and call the protected method initializeTableau with 2 arguments appropriately.
         * @param p_n Number of qubits in the system.
         */
        virtual void initializeTableau(uint p_n) = 0;

        /**
         * Virtual Destructor.
         */
        virtual ~StabilizerTableau() = default;

        /**
         * Transform the tableau according to the CNOT gate applied to qubits control and target.
         * After application the tableau stabilizes the state |ψ〉→ CNOT(control, target)|ψ〉.
         * @param control Control qubit a.
         * @param target Target qubit b.
         */
        virtual void CNOT(uint control, uint target) = 0;

        /**
         * Transform the tableau according to the Hadamard gate applied to the qubit qubit.
         * After application the tableau stabilizes the state |ψ〉→ H(qubit)|ψ〉.
         * @param qubit Qubit to apply the Hadamard gate to.
         */
        virtual void Hadamard(uint qubit) = 0;

        /**
         * Transform the tableau according to the Phase gate applied to the qubit qubit.
         * After application the tableau stabilizes the state |ψ〉→ Phase(qubit)|ψ〉.
         * @param qubit Qubit to apply the Phase gate to.
         */
        virtual void Phase(uint qubit) = 0;

        /**
         * Transform the tableau according to a measurement performed on qubit given by qubit.
         * @param qubit Qubit to measure.
         * @return The measurement outcome.
         */
        virtual uint8_t Measurement(uint qubit) = 0;

        /**
         * Apply the Identity gate to the qubit.
         * @param qubit Qubit to apply the Identity gate to.
         */
        void Identity(uint qubit) const;

        /**
         * Apply the Pauli X gate to the qubit via decomposition of X using Hadamard and Phase gates.
         * @param qubit Qubit to apply the Pauli-X gate to.
         */
        void PauliX(uint qubit);

        /**
         * Apply the Pauli Y gate to the qubit via decomposition of Y using Hadamard and Phase gates.
         * @param qubit Qubit to apply the Pauli-Y gate to.
         */
        void PauliY(uint qubit);

        /**
         * Apply the Pauli Z gate to the qubit via decomposition of Z using Phase gates.
         * @param qubit Qubit to apply the Pauli-Z gate to.
         */
        void PauliZ(uint qubit);
    };
}

stabilizer_tableau.cpp:
#include "stabilizer_tableau.h"

namespace CliffordTableaus {
    void StabilizerTableau::initializeTableau(uint p_n, uint p_total_bits) {
        this->n = p_n;
        this->total_bits = p_total_bits;
        this->tableau = std::vector<uint8_t>((total_bits + 7) / 8, 0);
    }

    void StabilizerTableau::Identity(uint qubit) const {
        if (qubit == 0) {
            throw std::invalid_argument("Attempted to apply Identity with qubit = 0!");
        }
        if (qubit > n) {
            throw std::invalid_argument("Attempted to apply Identity with qubit > n!");
        }
    }

    void StabilizerTableau::PauliX(uint qubit) {
        if (qubit == 0) {
            throw std::invalid_argument("Attempted to apply Pauli-X with qubit = 0!");
        }
        if (qubit > n) {
            throw std::invalid_argument("Attempted to apply Pauli-X with qubit > n!");
        }
        this->Hadamard(qubit);
        this->PauliZ(qubit);
        this->Hadamard(qubit);
    }

    void StabilizerTableau::PauliY(uint qubit) {
        if (qubit == 0) {
            throw std::invalid_argument("Attempted to apply Pauli-Y with qubit = 0!");
        }
        if (qubit > n) {
            throw std::invalid_argument("Attempted to apply Pauli-Y with qubit > n!");
        }
        this->PauliZ(qubit);
        this->PauliX(qubit);
        this->Phase(qubit);
        this->Phase(qubit);
        this->Phase(qubit);
        this->PauliX(qubit);
        this->Phase(qubit);
        this->Phase(qubit);
        this->Phase(qubit);
        this->PauliX(qubit);
    }

    void StabilizerTableau::PauliZ(uint qubit) {
        if (qubit == 0) {
            throw std::invalid_argument("Attempted to apply Pauli-Z with qubit = 0!");
        }
        if (qubit > n) {
            throw std::invalid_argument("Attempted to apply Pauli-Z with qubit > n!");
        }
        this->Phase(qubit);
        this->Phase(qubit);
    }
}

improved_simulation_of_stabilizer_circuits/improved_stabilizer_tableau.h:
#pragma once

#include "subroutines.h"
#include "stabilizer_tableau.h"

#include <iostream>
#include <cassert>
#include <cstdint>
#include <stdexcept>
#include <cstdint>
#include <vector>

namespace CliffordTableaus {
    using uint = std::size_t;

    /**
     * Improved stabilizer tableaus for a new simulation algorithm, by which both deterministic
     * and random measurements can be performed in O (n^2) time.
     * The cost is a factor-2 increase in the number of bits needed to specify a state.
     * For in addition to the n stabilizer generators, we now store n “destabilizer” generators,
     * which are Pauli operators that together with the stabilizer generators generate the full Pauli group Pn.
     * So the number of bits needed is 2*n*(2*n+1)=4*n^2+2*n.
     */
    class ImprovedStabilizerTableau : public StabilizerTableau {
    private:
        /**
         * It will be convenient to add an additional (2n + 1)st row for scratch space.
         * Using this scratch space allows one to override valid qubit index checks.
         * Use only when performing a measurement.
         */
        bool using_scratch_space = false;

        /**
         * The algorithm uses a subroutine called rowsum (h, i), which sets generator h equal to i + h.
         * Its purpose is to keep track, in particular, of the phase bit rh, including all the factors of i
         * that appear when multiplying Pauli matrices.
         * @param h The generator to update.
         * @param i The generator to add to h.
         */
        void rowsum(uint h, uint i);

        /**
         * Set the value of a bit in the tableau.
         * @param index The position of the bit.
         * @param value The value to which to set the bit to.
         */
        void set(uint index, uint8_t value);

        /**
         * Get the value of a bit in the tableau.
         * @param index The position of the bit.
         * @return The value of the bit.
         */
        uint8_t get(uint index);

        /**
         * Throws an invalid argument exception with the given message if the scratch space is not being used.
         * @param message Message to pass to std::invalid_argument.
         */
        void throw_invalid_argument(const std::string &message) const;

    public:
        /**
         * Construct a new ImprovedStabilizerTableau object.
         */
        ImprovedStabilizerTableau() = default;

        /**
         * Initialize the tableau with the given number of qubits and total bits.
         * The entries of the tableau will be default initialized to the state |0〉^(⊗n).
         * This state is represented by a tableau with its (2n)x(2n) submatrix set to identity.
         * @param p_n Number of qubits in the system.
         * @param p_total_bits Number of bits necessary to specify the state using the tableau.
         */
        void initializeTableau(uint p_n) override;

        /// Superclass overrides begin.
        void CNOT(uint control, uint target) override;

        void Hadamard(uint qubit) override;

        void Phase(uint qubit) override;

        uint8_t Measurement(uint qubit) override;
        /// Superclass overrides end.

        /**
         * Set the value of the x operator bit for a qubit.
         * @param i Index of the generator.
         * @param j Index of qubit.
         * @param x Value of the x operator bit.
         */
        void set_x(uint i, uint j, uint8_t x);

        /**
         * Set the value of the z operator bit for a qubit.
         * @param i Index of the generator.
         * @param j Index of qubit.
         * @param z Value of the z operator bit.
         */
        void set_z(uint i, uint j, uint8_t z);

        /**
         * Set the value of the phase operator bit for a qubit.
         * @param i Index of the generator.
         * @param r Value of the phase operator bit.
         */
        void set_r(uint i, uint8_t r);

        /**
         * Get the value of the x operator bit for a qubit.
         * @param i Index of the generator.
         * @param j Index of qubit.
         */
        uint8_t get_x(uint i, uint j);

        /**
         * Get the value of the z operator bit for a qubit.
         * @param i Index of the generator.
         * @param j Index of qubit.
         */
        uint8_t get_z(uint i, uint j);

        /**
         * Get the value of the phase operator bit-pair for a qubit.
         * The r variable consists of 2 bits to encode the possible values: 1, i, -1, -i.
         * @param i Index of the generator.
         */
        uint8_t get_r(uint i);
    };
}


improved_simulation_of_stabilizer_circuits/improved_stabilizer_tableau.cpp:
#include "improved_stabilizer_tableau.h"

namespace CliffordTableaus {
    void ImprovedStabilizerTableau::initializeTableau(uint p_n) {
        StabilizerTableau::initializeTableau(p_n, (2 * p_n + 1) * (2 * p_n + 1));
        // The initial state |0〉^⊗n has ri = 0 for all i ∈ {1 to 2n + 1},
        // and xij = δij and zij = δ(i−n)j for all
        // i ∈ {1 to 2n + 1} and j ∈ {1 to n}.
        for (uint i = 1; i <= n; ++i) {
            set_x(i, i, 1);
            set_z(n + i, i, 1);
            set_r(i, 0);
            set_r(n + i, 0);
        }
        using_scratch_space = true;
        for (uint j = 1; j <= n; ++j) {
            set_x(2 * n + 1, j, 0);
            set_z(2 * n + 1, j, 0);
        }
        set_r(2 * n + 1, 0);
        using_scratch_space = false;
    }


    void ImprovedStabilizerTableau::rowsum(uint h, uint i) {
        int rh = static_cast<int>(get_r(h));
        int ri = static_cast<int>(get_r(i));

        int sum_g = 2 * (rh + ri);
        for (uint j = 1; j <= n; ++j) {
            int xij = static_cast<int>(get_x(i, j));
            int zij = static_cast<int>(get_z(i, j));
            int xhj = static_cast<int>(get_x(h, j));
            int zhj = static_cast<int>(get_z(h, j));
            sum_g += g(xij, zij, xhj, zhj);
        }
        if (sum_g % 4 == 0) {
            set_r(h, 0);
        } else if (sum_g % 4 == 2) {
            set_r(h, 1);
        } else {
            throw std::logic_error("2*rh + 2*ri + sum_g should never be congruent to 1 or 3.");
        }

        for (uint j = 1; j <= n; ++j) {
            set_x(h, j, get_x(i, j) ^ get_x(h, j));
            set_z(h, j, get_z(i, j) ^ get_z(h, j));
        }
    }

    void ImprovedStabilizerTableau::CNOT(uint control, uint target) {
        if (control == 0) {
            throw_invalid_argument("Attempted to apply CNOT with control qubit = 0!");
        }
        if (control > n) {
            throw_invalid_argument("Attempted to apply CNOT with control qubit > n!");
        }
        if (target == 0) {
            throw_invalid_argument("Attempted to apply CNOT with target qubit = 0!");
        }
        if (target > n) {
            throw_invalid_argument("Attempted to apply CNOT with target qubit > n!");
        }
        if (control == target) {
            throw_invalid_argument("Attempted to apply CNOT with target qubit = control qubit!");
        }

        auto a = control;
        auto b = target;
        for (int i = 1; i <= 2 * n; ++i) {
            auto xia_zib = get_x(i, a) & get_z(i, b);
            auto xib_zia_1 = get_x(i, b) ^ get_z(i, a) ^ 1;
            set_r(i, get_r(i) ^ xia_zib & xib_zia_1);
            set_x(i, b, get_x(i, b) ^ get_x(i, a));
            set_z(i, a, get_z(i, a) ^ get_z(i, b));
        }
    }

    void ImprovedStabilizerTableau::Hadamard(uint qubit) {
        if (qubit == 0) {
            throw_invalid_argument("Attempted to apply Hadamard with qubit = 0!");
        }
        if (qubit > n) {
            throw_invalid_argument("Attempted to apply Hadamard with qubit > n!");
        }

        auto a = qubit;
        for (uint i = 1; i <= 2 * n; ++i) {
            set_r(i, get_r(i) ^ (get_x(i, a) & get_z(i, a)));
            auto new_xia = get_z(i, a);
            auto new_zia = get_x(i, a);
            set_x(i, a, new_xia);
            set_z(i, a, new_zia);
        }
    }

    void ImprovedStabilizerTableau::Phase(uint qubit) {
        if (qubit == 0) {
            throw_invalid_argument("Attempted to apply Phase with qubit = 0!");
        }
        if (qubit > n) {
            throw_invalid_argument("Attempted to apply Phase with qubit > n!");
        }

        auto a = qubit;
        for (uint i = 1; i <= 2 * n; ++i) {
            set_r(i, get_r(i) ^ (get_x(i, a) & get_z(i, a)));
            set_z(i, a, get_z(i, a) ^ get_x(i, a));
        }
    }

    uint8_t ImprovedStabilizerTableau::Measurement(uint qubit) {
        if (qubit == 0) {
            throw_invalid_argument("Attempted to measure qubit = 0!");
        }
        if (qubit > n) {
            throw_invalid_argument("Attempted to measure qubit > n!");
        }

        // Measurement of qubit a in standard basis.
        // First check whether there exists a p with n+1<=p<=2*n such that xpa=1.
        auto a = qubit;
        uint p;
        for (p = n + 1; p <= 2 * n; ++p) {
            if (get_x(p, a) == 1) {
                break;
            }
        }
        if (p <= 2 * n) {
            // Case I: Such a p exists.
            // If more than one exists, then let p be the smallest.
            // In this case the measurement outcome is random, so the state needs to be updated.
            // This is done as follows.
            // First call rowsum(i,p) for all i ∈ {1 to 2*n} such that i=/=p and xia = 1.
            for (int i = 1; i <= 2 * n; ++i) {
                if (i != p && get_x(i, a) == 1) {
                    rowsum(i, (int) p);
                }
            }

            // Second, set the entire (p−n)th row equal to the pth row.
            assert(p >= n + 1);
            for (uint j = 1; j <= n; ++j) {
                set_x(p - n, j, get_x(p, j));
                set_z(p - n, j, get_z(p, j));
            }
            set_r(p - n, get_r(p));

            // Third, set the pth row to be identically 0,
            // except that rp is 0 or 1 with equal probability,
            // and zpa = 1.
            for (uint j = 1; j <= n; ++j) {
                set_x(p, j, 0);
                set_z(p, j, 0);
            }
            set_r(p, random_bit());
            set_z(p, a, 1);

            // Finally, return rp as the measurement outcome.
            return get_r(p);
        }

        // Case II: Such a p does not exist.
        // In this case the outcome is determinate, so measuring the state will not change it.
        // The only task is to determine whether 0 or 1 is observed.
        // This is done as follows.
        // First set the (2n+1)st row to be identically 0.
        using_scratch_space = true;
        for (int j = 1; j <= n; ++j) {
            set_x(2 * n + 1, j, 0);
            set_z(2 * n + 1, j, 0);
        }
        set_r(2 * n + 1, 0);

        // Second, call rowsum (2n+1,i+n) for all i ∈ {1 to n} such that xia = 1.
        for (int i = 1; i <= n; ++i) {
            if (get_x(i, a) == 1) {
                rowsum(2 * (int) n + 1, i + (int) n);
            }
        }

        // Finally return r_{2n+1} as the measurement outcome.
        auto measurement = get_r(2 * n + 1);
        using_scratch_space = false;
        return measurement;
    }

    void ImprovedStabilizerTableau::set(uint index, uint8_t value) {
        uint byte_index = index / 8;
        uint bit_index = index % 8;
        tableau[byte_index] &= ~(1 << bit_index);
        tableau[byte_index] |= value << bit_index;
    }

    uint8_t ImprovedStabilizerTableau::get(uint index) {
        uint byte_index = index / 8;
        uint bit_index = index % 8;
        return (tableau[byte_index] >> bit_index) & 1;
    }


    void ImprovedStabilizerTableau::set_x(uint i, uint j, uint8_t x) {
        if (i == 0 || j == 0 || i > 2 * n || j > n) {
            throw_invalid_argument("Invalid indices for set_x.");
        }
        // Shift the index starting at 1 to index starting at 0
        set((i - 1) * (2 * n + 1) + (j - 1), x);
    }

    void ImprovedStabilizerTableau::set_z(uint i, uint j, uint8_t z) {
        if (i == 0 || j == 0 || i > 2 * n || j > n) {
            throw_invalid_argument("Invalid indices for set_z.");
        }
        // Shift the index starting at 1 to index starting at 0
        set((i - 1) * (2 * n + 1) + n + (j - 1), z);
    }

    void ImprovedStabilizerTableau::set_r(uint i, uint8_t r) {
        if (i == 0 || i > 2 * n) {
            throw_invalid_argument("Invalid index for set_r.");
        }
        // Shift the index starting at 1 to index starting at 0
        set((i - 1) * (2 * n + 1) + 2 * n, r);
    }

    uint8_t ImprovedStabilizerTableau::get_x(uint i, uint j) {
        if (i == 0 || j == 0 || i > 2 * n || j > n) {
            throw_invalid_argument("Invalid indices for get_x.");
        }
        // Shift the index starting at 1 to index starting at 0
        return get((i - 1) * (2 * n + 1) + (j - 1));
    }

    uint8_t ImprovedStabilizerTableau::get_z(uint i, uint j) {
        if (i == 0 || j == 0 || i > 2 * n || j > n) {
            throw_invalid_argument("Invalid indices for get_z.");
        }
        // Shift the index starting at 1 to index starting at 0
        return get((i - 1) * (2 * n + 1) + n + (j - 1));
    }

    uint8_t ImprovedStabilizerTableau::get_r(uint i) {
        if (i == 0 || i > 2 * n) {
            throw_invalid_argument("Invalid index for get_r.");
        }
        // Shift the index starting at 1 to index starting at 0
        return get((i - 1) * (2 * n + 1) + 2 * n);
    }

    void ImprovedStabilizerTableau::throw_invalid_argument(const std::string &message) const {
        if (!using_scratch_space) {
            throw std::invalid_argument(message);
        }
    }
}


improved_simulation_of_stabilizer_circuits/subroutines.h:
#pragma once

#include <cstdint>
#include <random>
#include <stdexcept>

namespace CliffordTableaus {
    using uint = std::size_t;
    /**
     * Random device for generating random bits.
     */
    static std::random_device randomDevice;

    /**
     * Mersenne Twister engine for generating random bits.
     */
    static std::mt19937 generator(randomDevice());

    /**
     * Uniform distribution for generating random bits.
     */
    static std::uniform_int_distribution<> distribution(0, 1);

    /**
     * Let g (x1, z1, x2, z2) be a function that takes 4 bits as input, and that returns the exponent
     * to which i is raised (either 0, 1, or −1) when the Pauli matrices represented by x1z1 and x2z2 are multiplied.
     * More explicitly:
     * if x1=z1=0 then g=0;
     * if x1=z1 = 1 then g=z2−x2;
     * if x1=1 and z1=0 then g=z2*(2*x2−1);
     * if x1=0 and z1=1 then g=x2*(1−2*z2).
     * @param x1z1x2z2 The 4 input bits stored in the least significant bits of an 8-bit unsigned integer.
     * @return The exponent to which i is raised when the Pauli matrices represented by x1z1 and x2z2 are multiplied.
     */
    int g(int x1, int z1, int x2, int z2);

    /**
     * Generate a random bit, either 0 or 1 with equal probability.
     * @return Random bit, either 0 or 1.
     */
    uint8_t random_bit();
}

improved_simulation_of_stabilizer_circuits/subroutines.cpp:
#include "subroutines.h"


namespace CliffordTableaus {
    int g(int x1, int z1, int x2, int z2) {
        switch ((x1 << 1) | z1) {
            case 0b00:
                return 0;
            case 0b11:
                return z2 - x2;
            case 0b10:
                return z2 * (2 * x2 - 1);
            case 0b01:
                return x2 * (1 - 2 * z2);
            default:
                throw std::invalid_argument("Invalid input to the g-function.");
        }
    }

    uint8_t random_bit() {
        return distribution(generator);
    }
}


